<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Cognitive Debugger v3</title>
    <style>
        :root {
            --bg: #0d1117;
            --panel: #161b22;
            --border: #30363d;
            --text: #c9d1d9;
            --accent: #58a6ff;
            --danger: #da3633;
            --success: #238636;
        }
        body {
            background: var(--bg); color: var(--text);
            font-family: 'Consolas', monospace;
            margin: 0; padding: 20px;
            display: flex; gap: 20px; height: 95vh; box-sizing: border-box;
        }

        /* Panels */
        .panel {
            background: var(--panel); border: 1px solid var(--border);
            border-radius: 6px; padding: 15px; display: flex; flex-direction: column;
        }
        #left-panel { flex: 0 0 auto; }
        #right-panel { flex: 1; min-width: 300px; gap: 10px; }

        /* Map */
        #map-container {
            position: relative;
            border: 2px solid #000;
            display: inline-block;
            background: #000;
        }
        #game-map { display: grid; }

        .tile {
            width: 20px; height: 20px;
            display: flex; align-items: center; justify-content: center;
            font-size: 16px; cursor: crosshair; user-select: none;
        }
        .tile:hover { background: #333; }
        .wall { background: #333; color: #555; }
        .floor { background: #111; color: #222; }

        /* Entities */
        .entity { cursor: pointer; z-index: 10; font-weight: bold; }
        .player { color: #58a6ff; text-shadow: 0 0 5px #58a6ff; }
        .enemy { color: #ff7b72; }
        .npc { color: #d29922; }

        /* Selection Ring */
        .selected {
            box-shadow: inset 0 0 0 2px var(--danger);
            background: rgba(218, 54, 51, 0.2) !important;
        }

        /* Controls */
        .control-group { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; }
        .d-pad { display: grid; grid-template-columns: repeat(3, 40px); gap: 5px; }

        button {
            background: #21262d; color: var(--text); border: 1px solid var(--border);
            padding: 8px 12px; cursor: pointer; border-radius: 6px; font-family: inherit;
        }
        button:hover { background: #30363d; }
        button:active { background: #1f2428; transform: translateY(1px); }
        button.primary { background: #238636; border-color: rgba(240,246,252,0.1); color: #fff; }
        button.danger { background: #da3633; border-color: rgba(240,246,252,0.1); color: #fff; }

        /* Logs */
        #logs {
            flex: 1; overflow-y: auto; background: #000;
            border: 1px solid var(--border); padding: 10px; font-size: 12px;
        }
        .log-line { margin-bottom: 4px; border-bottom: 1px solid #111; padding-bottom: 2px; }
        .t-COMBAT { color: #ff7b72; }
        .t-INFO { color: #8b949e; }
        .t-SPEECH { color: #f2cc60; font-style: italic; }

        /* HUD */
        #hud { margin-bottom: 10px; font-size: 13px; }
        .active-turn { border-color: var(--success); box-shadow: 0 0 10px var(--success); }
        .stat-val { color: var(--accent); font-weight: bold; }
    </style>
</head>
<body>

<div id="left-panel" class="panel">
    <div id="hud">
        Tick: <span id="tick" class="stat-val">0</span> |
        Pos: <span id="pos" class="stat-val">0,0</span> |
        Target: <span id="target-info" style="color: var(--danger)">None</span>
    </div>
    <div id="map-container">
        <div id="game-map">Connecting...</div>
    </div>
</div>

<div id="right-panel" class="panel">
    <div class="control-group">
        <div class="d-pad">
            <div></div>
            <button onclick="sendDir(0, -1)">W</button>
            <div></div>
            <button onclick="sendDir(-1, 0)">A</button>
            <button onclick="sendWait()">Wait</button>
            <button onclick="sendDir(1, 0)">D</button>
            <div></div>
            <button onclick="sendDir(0, 1)">S</button>
            <div></div>
        </div>
        <div style="display: flex; flex-direction: column; gap: 5px; width: 100%">
            <button class="danger" onclick="sendAction('ATTACK')">‚öîÔ∏è ATTACK (Target)</button>
            <button class="primary" onclick="sendAction('TALK')">üí¨ TALK (Target)</button>
            <button onclick="sendAction('INIT')">üîÑ RESET</button>
        </div>
    </div>

    <div style="font-size: 11px; color: #666">
        Controls: WASD to Move, SPACE to Wait, Click entity to Target.
    </div>

    <div id="logs"></div>
</div>

<script>
    const ws = new WebSocket("ws://localhost:8080/ws");

    // State
    let myId = "";
    let selectedTarget = null;
    let gridInitialized = false;
    let entitiesCache = [];

    // UI Refs
    const mapEl = document.getElementById("game-map");
    const leftPanel = document.getElementById("left-panel");
    const targetLabel = document.getElementById("target-info");

    ws.onmessage = (evt) => {
        const msg = JSON.parse(evt.data);

        if (msg.type === "INIT" || msg.type === "UPDATE") {
            if (msg.player) myId = msg.player.id;

            // Render
            if (msg.world) renderMap(msg.world);
            if (msg.entities) {
                entitiesCache = [...msg.entities];
                if (msg.player) entitiesCache.push(msg.player); // Add player to visuals
                drawEntities(entitiesCache);
            }
            if (msg.player) updateStats(msg.player, msg.world?.globalTick);
            if (msg.logs) renderLogs(msg.logs);

            // Turn Indicator
            if (msg.activeEntityId && msg.activeEntityId === myId) {
                leftPanel.classList.add("active-turn");
            } else {
                leftPanel.classList.remove("active-turn");
            }
        }
    };

    // --- Controls ---

    function sendDir(dx, dy) {
        ws.send(JSON.stringify({
            action: "MOVE",
            payload: { dx, dy } // DirectionPayload
        }));
    }

    function sendWait() {
        ws.send(JSON.stringify({ action: "WAIT", payload: {} }));
    }

    function sendAction(action) {
        if (!selectedTarget) {
            alert("Select a target on the map first!");
            return;
        }
        ws.send(JSON.stringify({
            action: action,
            payload: { targetId: selectedTarget } // EntityPayload
        }));
    }

    // Keyboard
    document.addEventListener("keydown", (e) => {
        if (e.key === "w") sendDir(0, -1);
        if (e.key === "s") sendDir(0, 1);
        if (e.key === "a") sendDir(-1, 0);
        if (e.key === "d") sendDir(1, 0);
        if (e.key === " ") sendWait();
    });

    // --- Core Rendering ---

    function initGrid(w, h) {
        mapEl.innerHTML = '';
        mapEl.style.gridTemplateColumns = `repeat(${w}, 20px)`;
        mapEl.style.gridTemplateRows = `repeat(${h}, 20px)`;

        for(let y=0; y<h; y++) {
            for(let x=0; x<w; x++) {
                const div = document.createElement("div");
                div.id = `t-${x}-${y}`;
                div.className = "tile";
                div.onclick = () => selectTile(x, y); // Click to select
                mapEl.appendChild(div);
            }
        }
        gridInitialized = true;
    }

    function renderMap(world) {
        if (!gridInitialized) initGrid(world.width, world.height);

        world.map.forEach(row => {
            row.forEach(tile => {
                const el = document.getElementById(`t-${tile.x}-${tile.y}`);
                if (!el) return;

                // Reset
                el.className = "tile";
                el.innerText = "";
                el.style.backgroundColor = "";

                if (tile.isWall) {
                    el.classList.add("wall");
                    el.innerText = "#";
                } else {
                    el.classList.add("floor");
                    el.innerText = ".";
                }
            });
        });
    }

    function drawEntities(entities) {
        entities.forEach(e => {
            // –£–±–µ–¥–∏—Å—å, —á—Ç–æ ID —è—á–µ–µ–∫ —Å–æ–≤–ø–∞–¥–∞—é—Ç —Å —Ç–µ–º–∏, —á—Ç–æ –≤ renderMap (t-x-y –∏–ª–∏ c-x-y)
            // –í –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤–µ—Ä—Å–∏–∏ –±—ã–ª–æ t-${x}-${y}
            const el = document.getElementById(`t-${e.pos.x}-${e.pos.y}`);
            if (!el) return;

            // 1. –î–æ—Å—Ç–∞–µ–º –°–∏–º–≤–æ–ª –∏–∑ RenderComponent
            if (e.render) {
                el.innerText = e.render.symbol;
            } else {
                el.innerText = "?"; // –ï—Å–ª–∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞ –Ω–µ—Ç
            }

            el.className = "tile entity"; // –°–±—Ä–æ—Å –∫–ª–∞—Å—Å–æ–≤

            // 2. –ö—Ä–∞—Å–∏–º –ø–æ —Ç–∏–ø–∞–º
            if (e.type === "PLAYER") el.classList.add("player");
            else if (e.type === "ENEMY") el.classList.add("enemy");
            else if (e.type === "NPC") el.classList.add("npc");

            // 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —Å–º–µ—Ä—Ç—å (—Ç–µ–ø–µ—Ä—å –≤–Ω—É—Ç—Ä–∏ Stats)
            if (e.stats && e.stats.isDead) {
                el.classList.remove("enemy", "npc", "player");
                el.classList.add("corpse");
                el.style.color = "#555";
            }

            // –í—ã–¥–µ–ª–µ–Ω–∏–µ —Ü–µ–ª–∏
            if (e.id === selectedTarget) {
                el.classList.add("selected");
            }
        });
    }

    // --- Selection Logic ---

    function selectTile(x, y) {
        // Find entity at this pos
        const ent = entitiesCache.find(e => e.pos.x === x && e.pos.y === y && !e.isDead && e.id !== myId);

        if (ent) {
            selectedTarget = ent.id;
            targetLabel.innerText = `${ent.name} (${ent.id})`;
            targetLabel.style.color = "#fff";
        } else {
            selectedTarget = null;
            targetLabel.innerText = "None";
            targetLabel.style.color = "#555";
        }

        // Redraw to show selection ring
        drawEntities(entitiesCache);
    }

    function updateStats(p, tick) {
        document.getElementById("tick").innerText = tick;
        document.getElementById("pos").innerText = `${p.pos.x},${p.pos.y}`;
    }

    const logsEl = document.getElementById("logs");
    function renderLogs(logs) {
        logs.forEach(l => {
            const row = document.createElement("div");
            row.className = `log-line t-${l.type}`;
            const time = new Date(l.timestamp).toLocaleTimeString();
            row.innerText = `[${time}] ${l.text}`;
            logsEl.appendChild(row);
        });
        logsEl.scrollTop = logsEl.scrollHeight;
    }
</script>

</body>
</html>